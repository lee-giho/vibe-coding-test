# 짜장면 vs 짬뽕 투표 웹서비스 상세 기능 명세서 (Flask + MySQL + Docker Compose)

> 본 문서는 **PRD를 바탕으로 개발자가 바로 구현 가능한 수준**으로, 기능별 **입력값/출력값/예외 처리**를 포함한 상세 명세서입니다.  
> 프론트: HTML/CSS/Vanilla JS, 백엔드: Flask, DB: MySQL(Compose).  
> RESTful 기준으로 **투표는 POST**, **결과 조회는 GET**을 사용합니다.

---

## 0. 문서 메타

- 문서 버전: v1.0
- 기준 날짜: 2025-12-30 (KST)
- 대상 독자: 백엔드/프론트엔드 개발자, DevOps

---

## 1. 용어/규칙

### 1.1 용어
- **Poll**: 투표 주제(현재는 “짜장면 vs 짬뽕” 1개 고정 운영)
- **Option**: 투표 선택지(짜장면/짬뽕)
- **Vote**: 사용자 1회 투표 기록(로그)
- **Results**: 현재 집계 결과(옵션별 count, percent, totalVotes)

### 1.2 공통 규칙
- API Base URL: `/api/v1`
- Content-Type: `application/json`
- 타임존: `Asia/Seoul` (KST, `+09:00`)

### 1.3 응답 포맷(표준)
모든 API는 다음 JSON 래퍼를 사용한다.

```json
{
  "success": true,
  "data": {},
  "error": null
}
```

실패 시:

```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "optionId is required",
    "details": { "field": "optionId" }
  }
}
```

---

## 2. 기능 목록(개발 단위)

### 2.1 프론트엔드
- FE-01: 최초 로딩(결과 조회) 및 상태 처리(loading/empty/success/error)
- FE-02: 투표 제출(POST) 및 결과 즉시 반영
- FE-03: 실시간 결과 갱신(기본: 폴링, 옵션: SSE + fallback)
- FE-04: 오류 안내/재시도 UX(토스트/배너/버튼)

### 2.2 백엔드(API)
- BE-01: 결과 조회 API `GET /results`
- BE-02: 투표 API `POST /votes`
- BE-03(옵션): SSE 스트림 `GET /results/stream`
- BE-04(권장): 헬스체크 `GET /health`
- BE-05(권장): 초기 데이터 시드(투표 1개 + 옵션 2개)

### 2.3 인프라/DB
- INF-01: MySQL 컨테이너(볼륨 포함) 구성
- INF-02: Flask API 컨테이너 구성 및 MySQL 연결
- INF-03: DB 마이그레이션/초기 스키마 적용 전략(간단 SQL + entrypoint)

---

## 3. 데이터 명세(MySQL)

> 목표: 재접속/재시작에도 결과 유지(영속).  
> 집계 성능을 위해 `options.vote_count`를 캐시 컬럼으로 둠(서버에서 트랜잭션으로 증가).

### 3.1 테이블 정의

#### 3.1.1 `polls`
| 컬럼명 | 타입 | 제약 | 설명 |
|---|---|---|---|
| id | INT | PK, AUTO_INCREMENT | poll 식별자 |
| title | VARCHAR(100) | NOT NULL | “짜장면 vs 짬뽕” |
| is_active | TINYINT(1) | NOT NULL DEFAULT 1 | 활성 여부 |
| created_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 생성 시각 |

권장 인덱스
- `idx_polls_active (is_active)`

#### 3.1.2 `options`
| 컬럼명 | 타입 | 제약 | 설명 |
|---|---|---|---|
| id | INT | PK, AUTO_INCREMENT | option 식별자 |
| poll_id | INT | FK(polls.id), NOT NULL | poll 참조 |
| label | VARCHAR(50) | NOT NULL | “짜장면”, “짬뽕” |
| vote_count | INT | NOT NULL DEFAULT 0 | 집계 카운트 |
| created_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 생성 시각 |

제약/인덱스
- FK: `options.poll_id -> polls.id`
- Unique: `(poll_id, label)` (같은 poll에 같은 라벨 중복 방지)
- Index: `idx_options_poll (poll_id)`

#### 3.1.3 `votes`
| 컬럼명 | 타입 | 제약 | 설명 |
|---|---|---|---|
| id | BIGINT | PK, AUTO_INCREMENT | vote 식별자 |
| poll_id | INT | FK(polls.id), NOT NULL | poll 참조 |
| option_id | INT | FK(options.id), NOT NULL | option 참조 |
| client_hash | CHAR(64) | NULL | (선택) 악용 방지용 해시 |
| created_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 투표 시각 |

인덱스
- `idx_votes_poll_created (poll_id, created_at)`
- `idx_votes_option (option_id)`
- (선택) 중복 제한 정책을 쓰면 `idx_votes_client_hash (client_hash, created_at)`

---

### 3.2 초기 데이터 시드(권장)
- polls: 1개 생성(활성=1)
- options: 2개 생성(짜장면/짬뽕)

예시(개발용):
- pollId=1
- optionId=10(짜장면), optionId=11(짬뽕) 처럼 고정할 필요는 없지만,
  프론트는 **GET results 응답의 optionId**를 사용해야 하므로 하드코딩 금지.

---

## 4. API 상세 명세(RESTful)

## 4.1 BE-01 결과 조회 (필수)
### `GET /api/v1/results`
현재 누적 결과를 조회한다.

#### 입력값
- Query Parameters
  - `pollId` (int, required): 조회할 poll id

#### 요청 예시
`GET /api/v1/results?pollId=1`

#### 출력값(성공)
- Status: `200 OK`
- Body:
```json
{
  "success": true,
  "data": {
    "pollId": 1,
    "title": "짜장면 vs 짬뽕",
    "totalVotes": 123,
    "options": [
      { "optionId": 10, "label": "짜장면", "count": 70, "percent": 56.91 },
      { "optionId": 11, "label": "짬뽕", "count": 53, "percent": 43.09 }
    ],
    "updatedAt": "2025-12-30T14:00:00+09:00"
  },
  "error": null
}
```

#### percent 계산 규칙
- `totalVotes = sum(options[].count)`
- `percent = (count / totalVotes) * 100`
- `totalVotes == 0`이면 모든 `percent=0`
- 소수점 정책: 서버에서 **소수점 2자리 반올림**하여 내려주거나(권장),
  프론트에서 포맷팅 가능(둘 중 하나로 고정)

#### 예외 처리(실패)
| 상황 | Status | error.code | message 예시 |
|---|---:|---|---|
| pollId 누락/타입 오류 | 400 | VALIDATION_ERROR | "pollId is required" |
| pollId 없음 | 404 | NOT_FOUND | "poll not found" |
| DB 연결 실패 | 503 | DB_UNAVAILABLE | "database unavailable" |
| 기타 서버 오류 | 500 | INTERNAL_ERROR | "unexpected error" |

#### 서버 처리 로직(요약)
1) poll 존재/활성 여부 확인(활성은 운영 정책에 따라 결과 조회는 허용 가능)
2) options 조회
3) totalVotes, percent 계산
4) updatedAt = 서버 현재 시각(또는 마지막 투표 시각 기반도 가능)

---

## 4.2 BE-02 투표하기 (필수)
### `POST /api/v1/votes`
사용자가 옵션 하나에 투표한다.

#### 입력값
- Headers
  - `Content-Type: application/json`
- Body
```json
{
  "pollId": 1,
  "optionId": 10
}
```

#### 유효성 검증(Validation)
- `pollId` 필수, int
- `optionId` 필수, int
- poll 존재해야 함
- option이 해당 poll에 속해야 함
- poll이 활성 상태여야 함(`is_active=1`)

#### 출력값(성공)
- Status: `200 OK`
- Body: 투표 반영 후 최신 결과를 함께 반환(프론트 즉시 갱신)
```json
{
  "success": true,
  "data": {
    "pollId": 1,
    "optionId": 10,
    "results": {
      "totalVotes": 124,
      "options": [
        { "optionId": 10, "label": "짜장면", "count": 71, "percent": 57.26 },
        { "optionId": 11, "label": "짬뽕", "count": 53, "percent": 42.74 }
      ],
      "updatedAt": "2025-12-30T14:00:05+09:00"
    }
  },
  "error": null
}
```

#### 예외 처리(실패)
| 상황 | Status | error.code | message 예시 |
|---|---:|---|---|
| Body 누락/필드 누락/타입 오류 | 400 | VALIDATION_ERROR | "optionId is required" |
| poll/option 없음 | 404 | NOT_FOUND | "option not found" |
| option이 poll에 속하지 않음 | 400 | VALIDATION_ERROR | "optionId does not belong to pollId" |
| poll 비활성 | 409 | POLL_INACTIVE | "poll is inactive" |
| (선택) 중복 투표 제한 위반 | 409 | VOTE_LIMITED | "try again later" |
| DB 연결 실패 | 503 | DB_UNAVAILABLE | "database unavailable" |
| 기타 서버 오류 | 500 | INTERNAL_ERROR | "unexpected error" |

#### 트랜잭션 요구사항(필수)
투표는 **아래 2개 작업이 함께 성공**해야 한다.
1) `votes` 로그 insert  
2) `options.vote_count` +1 업데이트

**원자성 보장 방법(권장)**  
- InnoDB 트랜잭션 사용
- `UPDATE options SET vote_count = vote_count + 1 WHERE id=? AND poll_id=?;`
- 업데이트 행 수가 0이면 유효하지 않은 option으로 처리

#### 동시성(중요)
- 동시 투표 시 카운트 누락이 없어야 함.
- `vote_count = vote_count + 1` 형태는 원자적 증가로 동시성에 안전.

---

## 4.3 BE-03 결과 스트림 (옵션, 권장)
### `GET /api/v1/results/stream`
SSE(Server-Sent Events)로 결과 변경을 푸시한다.

#### 입력값
- Query: `pollId` (required)

#### 출력(성공)
- Status: `200 OK`
- Headers:
  - `Content-Type: text/event-stream`
  - `Cache-Control: no-cache`
  - `Connection: keep-alive`

#### 이벤트 포맷(예시)
```
event: results_updated
data: {"pollId":1,"totalVotes":124,"options":[...],"updatedAt":"..."}

```
- 서버는 투표 발생 시 해당 poll 구독자에게 이벤트 전송
- 주기적인 keep-alive(예: 15~30초)도 권장

#### 예외 처리
- pollId 검증 실패: 연결을 즉시 종료하거나, `event: error` 전송 후 종료
- 서버 과부하 시 503 반환 가능

> 구현 난이도가 올라가므로, MVP는 폴링만으로도 출시 가능. SSE는 UX/트래픽 최적화 시 도입.

---

## 4.4 BE-04 헬스체크 (권장)
### `GET /api/v1/health`
서버/DB 연결 상태를 확인한다.

#### 출력값
- 200 OK:
```json
{
  "success": true,
  "data": { "status": "ok", "db": "ok", "time": "2025-12-30T14:01:00+09:00" },
  "error": null
}
```
- DB 오류 시 503:
```json
{
  "success": false,
  "data": null,
  "error": { "code": "DB_UNAVAILABLE", "message": "database unavailable", "details": null }
}
```

---

## 5. 프론트엔드 상세 명세

## 5.1 FE-01 최초 로딩 및 상태 처리
### 화면 상태(state machine)
- `loading`: 최초 진입/재시도 시
- `success`: 결과 정상 조회 & totalVotes >= 1
- `empty`: 결과 정상 조회 & totalVotes == 0
- `error`: 결과 조회 실패

### 입력값
- 사용자 페이지 진입(브라우저 load)
- 내부적으로 `GET /api/v1/results?pollId=1` 호출(초기 pollId는 고정 상수로 두되, 향후 확장 시 URL param 고려)

### 출력값(UI)
- loading: 스피너/스켈레톤 표시
- empty: “첫 투표를 해보세요!” + 옵션 버튼 활성화
- success: 결과(득표수/퍼센트/막대 그래프) 표시
- error: 오류 메시지 + “다시 시도” 버튼

### 예외 처리
- fetch 실패/timeout → error
- 404 poll not found → error(운영 문제로 안내)
- 503 → “서버 점검/DB 연결 문제” 안내 + 재시도

---

## 5.2 FE-02 투표 제출 및 즉시 반영
### 동작
- 사용자가 옵션(짜장면/짬뽕) 버튼 클릭
- 버튼 연타 방지: 클릭 후 응답 올 때까지 **투표 버튼 비활성화**
- `POST /api/v1/votes` 호출 후 성공 시 `results`로 UI 즉시 갱신

### 입력값
- 클릭한 옵션의 `optionId`
- `pollId` (고정 또는 설정값)

### 출력값
- 성공: 최신 results로 렌더, “투표 반영됨” 토스트(선택)
- 실패: 에러 코드별 안내(아래)

### 예외 처리(프론트 정책)
| Status | error.code | 사용자 안내(UI) | 처리 |
|---:|---|---|---|
| 400 | VALIDATION_ERROR | “요청이 올바르지 않습니다.” | 개발/운영 로그에 details 남김 |
| 404 | NOT_FOUND | “투표 항목을 찾을 수 없습니다.” | 새로고침 유도 |
| 409 | VOTE_LIMITED | “잠시 후 다시 시도해 주세요.” | 버튼 재활성화 |
| 409 | POLL_INACTIVE | “현재 투표가 종료되었습니다.” | 버튼 비활성 유지 |
| 503 | DB_UNAVAILABLE | “서버 연결이 불안정합니다.” | 재시도 가능 |
| 500 | INTERNAL_ERROR | “서버 오류가 발생했습니다.” | 재시도 가능 |

---

## 5.3 FE-03 실시간 갱신

### 5.3.1 기본(필수): 폴링
- 주기: 2~5초(권장 3초)
- 방법: `setInterval`로 `GET /results` 호출
- 주의: 탭 비활성 시 불필요 트래픽 줄이기 위해 `visibilitychange` 이벤트로 폴링 일시 중지 가능(권장)

예외 처리
- 연속 실패 N회(예: 3회) 시 상태를 `error`로 전환하고 폴링 잠시 중지(예: 10초 후 재시작)

### 5.3.2 옵션: SSE + fallback
- SSE 연결 성공 시 폴링 중지
- SSE `onerror` 발생하면 폴링 재개(자동 fallback)
- SSE `onmessage` 또는 특정 `event` 처리하여 results 갱신

---

## 5.4 FE-04 오류/재시도 UX
- Error 상태에서 “다시 시도” 버튼 제공
- 재시도 시 state를 loading으로 변경 후 `GET /results` 재호출
- 네트워크 오류는 브라우저 기본 메시지 대신 사용자 친화 문구 사용

---

## 6. 백엔드(Flask) 구현 명세(구조/규칙)

## 6.1 모듈 구성(권장 파일 구조)
```
backend/
  app.py                 # Flask app factory / route 등록
  config.py              # 환경변수 기반 설정
  db.py                  # MySQL 연결(풀) 유틸
  repositories/
    poll_repo.py
    vote_repo.py
  services/
    poll_service.py      # 결과 계산, 투표 처리(트랜잭션)
  routes/
    api_v1.py            # /api/v1 라우트
  utils/
    errors.py            # 표준 에러 응답
    time.py              # KST ISO 포맷
```

> DB 라이브러리는 `mysql-connector-python` 또는 `PyMySQL` + `SQLAlchemy(선택)` 중 택1.
> 단순/명확성을 위해 **직접 SQL + 커넥션 풀**도 가능.

---

## 6.2 입력 검증 규칙
- `pollId`, `optionId`는 `int`로 파싱 가능해야 함
- 숫자 범위: 1 이상
- 요청 body는 JSON 파싱 실패 시 400 반환

---

## 6.3 표준 에러 응답 생성기(권장)
- `make_error(status, code, message, details=None)`
- 모든 실패 응답은 동일 포맷 유지

---

## 7. Docker Compose 상세 명세

## 7.1 서비스 구성(최소)
- `mysql`: MySQL 8.x
- `api`: Flask + gunicorn(권장)

## 7.2 환경 변수(.env 권장)
| 변수 | 예시 | 설명 |
|---|---|---|
| MYSQL_HOST | mysql | 컨테이너 서비스명 |
| MYSQL_PORT | 3306 | 포트 |
| MYSQL_DATABASE | poll_db | DB명 |
| MYSQL_USER | poll_user | 사용자 |
| MYSQL_PASSWORD | ***** | 비밀번호 |
| MYSQL_ROOT_PASSWORD | ***** | 루트 비밀번호 |
| APP_PORT | 5000 | Flask 포트 |

## 7.3 데이터 영속성
- MySQL 데이터는 named volume(예: `mysql_data`)에 저장

## 7.4 초기 스키마 적용 전략(택1)
1) MySQL 컨테이너 `docker-entrypoint-initdb.d/`에 `schema.sql`, `seed.sql` 마운트(가장 간단)
2) Flask 시작 시 마이그레이션 스크립트 실행(관리 복잡도 증가)

권장: (1)

---

## 8. 보안/악용 방지 정책(선택 기능, 권장)

## 8.1 중복 투표 제한(완벽 불가, “완화” 목적)
- 정책 예시: 동일 `client_hash`로 10초 내 재투표 시 409(VOTE_LIMITED)
- `client_hash` 생성(서버):
  - raw = `IP + User-Agent + secret_salt`
  - `sha256(raw)` 저장
- 개인정보 원문(IP/UA)은 저장하지 않음(해시만 저장)

예외 처리
- 프록시/모바일망 등으로 IP가 바뀔 수 있으므로, “강제 1인 1표”가 아니라 **남용 방지** 용도로만 사용

## 8.2 Rate Limit(선택)
- IP 기준 분당 N회 제한(예: 60)
- 초과 시 429 반환(선택) + `RATE_LIMITED` 코드

---

## 9. 로깅/모니터링(권장)

- 요청 로그: method, path, status, latency
- 투표 로그: pollId, optionId, 성공/실패, latency
- 에러 로그: stacktrace(서버만), 응답에는 일반 메시지

---

## 10. QA/테스트 케이스(필수 합격 기준)

### 10.1 기능 테스트
1) 초기 totalVotes=0 → Empty 상태 노출
2) 투표 1회 → 결과 즉시 반영, 새로고침 후 유지
3) 다른 브라우저/시크릿 모드 접속 → 같은 결과 조회
4) 동시 투표(20~100회) → 합계 누락 없음
5) DB 컨테이너 재시작 → 데이터 유지
6) API 중단/네트워크 차단 → Error UI 노출 및 재시도 동작

### 10.2 예외 테스트
- pollId 누락/문자열 → 400
- optionId가 다른 poll의 option → 400
- 존재하지 않는 option → 404
- DB down → 503

---

## 11. 수용 기준(Acceptance Criteria)

- [ ] `POST /votes`와 `GET /results`가 명세대로 동작한다.
- [ ] 결과는 MySQL에 저장되어 재접속/재시작에도 유지된다.
- [ ] 프론트는 loading/empty/success/error 상태를 모두 지원한다.
- [ ] 실시간 갱신(최소 폴링)이 동작한다.
- [ ] 동시 투표 시 vote_count 누락이 없다(원자적 증가 + 트랜잭션).

---

## 부록 A. API 스키마 요약

### ResultsDTO
```json
{
  "pollId": 1,
  "title": "string",
  "totalVotes": 0,
  "options": [
    { "optionId": 10, "label": "string", "count": 0, "percent": 0.0 }
  ],
  "updatedAt": "ISO8601+TZ"
}
```

### VoteRequestDTO
```json
{ "pollId": 1, "optionId": 10 }
```

---

## 부록 B. 프론트 구현 체크리스트(코파일럿 프롬프트용)
- [ ] `index.html`: 옵션 카드 + 결과 바 UI 레이아웃
- [ ] `styles.css`: 반응형(모바일 우선), 버튼/카드/프로그레스 바 스타일
- [ ] `app.js`: state 머신 구현
- [ ] `app.js`: `fetchResults()` / `submitVote(optionId)` 구현
- [ ] 폴링 매니저 구현(visibilitychange로 최적화)
- [ ] (옵션) SSE 매니저 + fallback 구현
